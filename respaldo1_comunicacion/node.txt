// ==== ATmega328P / Arduino UNO (UART0 D0/D1) + RYLR896 - CÃ“DIGO ORIGINAL PROBADO ====
#include <Arduino.h>

#define LORA Serial
const int PIN_LED_RED   = 4;
const int PIN_LED_GREEN = 3;

#ifndef NETWORK_ID
#define NETWORK_ID 0
#endif

#define RY_BAUD 9600
const uint8_t MY_ID     = 20;
const uint8_t MASTER_ID = 1;

// Timings
const uint16_t CMD_GAP_MS    = 90;
const uint16_t AT_TO_MS      = 900;
const uint16_t SEND_TO_MS    = 1000;
const uint32_t TX_PERIOD_MS  = 3000;

// Conectividad
const uint32_t RX_ALIVE_MS     = 12000;
const uint32_t ACK_WAIT_MS     = 2000;
const uint8_t  ACK_FAIL_THRESH = 3;

// Estado
uint32_t seq = 0, lastSeqTx = 0;
unsigned long lastTx = 0, lastRxMs = 0, ackDeadline = 0;
bool cfg_ok=false, waitingAck=false;
uint8_t ackFailStreak=0;
bool redBlinkOn=false; unsigned long redBlinkT0=0;
const uint16_t RED_ON_MS=120, RED_OFF_MS=880;

void ledBoth(bool on){ digitalWrite(PIN_LED_RED,on); digitalWrite(PIN_LED_GREEN,on); }
void blinkBoth(uint8_t n){ for(uint8_t i=0;i<n;i++){ ledBoth(true); delay(150); ledBoth(false); delay(150);} }
void ticGreen(){ digitalWrite(PIN_LED_GREEN,1); delay(60); digitalWrite(PIN_LED_GREEN,0); }

void clearInput(){ while (LORA.available()) (void)LORA.read(); }

bool waitLine(String& out, unsigned long to=AT_TO_MS){
  unsigned long t0=millis(); out="";
  while (millis()-t0 < to){
    while (LORA.available()){
      char c=(char)LORA.read();
      if (c=='\n' || c=='\r'){ out.trim(); if(out.length()) return true; else continue; }
      out += c;
    }
  }
  return out.length()>0;
}

bool parseRCV(const String& line, String& outData, int& rssi, int& snr){
  if(!line.startsWith("+RCV=")) return false;
  int p1=line.indexOf(','), p2=line.indexOf(',',p1+1), p3=line.indexOf(',',p2+1), p4=line.indexOf(',',p3+1);
  if(p1<0||p2<0||p3<0||p4<0) return false;
  outData = line.substring(p2+1,p3);
  rssi    = line.substring(p3+1,p4).toInt();
  snr     = line.substring(p4+1).toInt();
  return true;
}
bool parseMesh(const String& s, uint8_t& src,uint8_t& dst,uint8_t& ttl,uint32_t& sq,String& pl){
  if(!s.startsWith("M,")) return false;
  int p1=s.indexOf(',',2), p2=s.indexOf(',',p1+1), p3=s.indexOf(',',p2+1), p4=s.indexOf(',',p3+1);
  if(p1<0||p2<0||p3<0||p4<0) return false;
  src=(uint8_t)s.substring(2,p1).toInt();
  dst=(uint8_t)s.substring(p1+1,p2).toInt();
  ttl=(uint8_t)s.substring(p2+1,p3).toInt();
  sq =(uint32_t)s.substring(p3+1,p4).toInt();
  pl = s.substring(p4+1);
  return true;
}

void handleRCVForAck(const String& line){
  String data; int rssi=0, snr=0;
  if(!parseRCV(line, data, rssi, snr)) return;
  lastRxMs = millis();
  uint8_t src,dst,ttl; uint32_t sq; String pl;
  if(!parseMesh(data, src, dst, ttl, sq, pl)) return;
  if(dst==MY_ID && waitingAck && sq==lastSeqTx && (pl.startsWith("ACK") || pl.startsWith("PONG"))){
    waitingAck=false;
    ackFailStreak=0;
    lastRxMs=millis();
  }
}

bool sendAT(const String& cmd, unsigned long to=AT_TO_MS){
  clearInput();
  LORA.print(cmd); LORA.print("\r\n");
  String line; bool ok=false; unsigned long t0=millis();
  while (millis()-t0 < to){
    if (waitLine(line, to)){
      if (line.startsWith("+RCV=")){
        handleRCVForAck(line);
        continue;
      }
      if (line.indexOf("+ERR")!=-1) return false;
      if (line.indexOf("+OK")!=-1 || line.indexOf("+READY")!=-1) ok=true;
    }
  }
  return ok;
}

bool autobaud_fix_9600(){
  const long BAUDS[] = {115200,57600,38400,19200,9600};
  for (unsigned i=0;i<sizeof(BAUDS)/sizeof(BAUDS[0]);i++){
    LORA.begin(BAUDS[i]); delay(200);
    for(uint8_t k=0;k<3;k++){
      if(sendAT("AT",600)){
        delay(CMD_GAP_MS);
        (void)sendAT("AT+IPR=9600",800);
        delay(150); LORA.end(); delay(50); LORA.begin(9600); delay(150);
        for(uint8_t j=0;j<3;j++) if(sendAT("AT",800)) return true;
        break;
      }
      delay(120);
    }
  }
  return false;
}

bool cfgRYLR(){
  uint8_t tries=0; while(tries<3 && !sendAT("AT",600)){ tries++; delay(150); }
  if(tries>=3) return false;
  bool ok=true;
  ok &= sendAT("AT+IPR=9600",800); delay(CMD_GAP_MS);
  ok &= sendAT("AT+BAND=915000000",800); delay(CMD_GAP_MS);
  ok &= sendAT("AT+PARAMETER=7,7,1,10",800);delay(CMD_GAP_MS);
  ok &= sendAT(String("AT+NETWORKID=")+String(NETWORK_ID),800); delay(CMD_GAP_MS);
  ok &= sendAT("AT+ADDRESS=20",800); delay(CMD_GAP_MS);
  ok &= sendAT("AT+CRFOP=14",800); delay(CMD_GAP_MS);
  return ok;
}

inline bool meshAlive(){ return (millis()-lastRxMs) <= RX_ALIVE_MS; }
void driveConnLED(){
  if(!cfg_ok) return;
  if(meshAlive()){
    if(redBlinkOn){ redBlinkOn=false; digitalWrite(PIN_LED_RED,LOW); }
  }else{
    unsigned long now=millis();
    if(redBlinkOn){
      if(now-redBlinkT0>=RED_ON_MS){ redBlinkOn=false; digitalWrite(PIN_LED_RED,LOW); redBlinkT0=now; }
    }else{
      if(now-redBlinkT0>=RED_OFF_MS){ redBlinkOn=true; digitalWrite(PIN_LED_RED,HIGH); redBlinkT0=now; }
    }
  }
}

void setup(){
  pinMode(PIN_LED_RED,OUTPUT);
  pinMode(PIN_LED_GREEN,OUTPUT);
  ledBoth(false); blinkBoth(2);

  if(!autobaud_fix_9600()){ ledBoth(true); while(true){} }
  cfg_ok = cfgRYLR();
  if(!cfg_ok) digitalWrite(PIN_LED_RED,HIGH);
}

void loop(){
  if(millis()-lastTx > TX_PERIOD_MS){
    lastTx = millis();
    lastSeqTx = seq++;
    String payload = "M,"+String(MY_ID)+","+String(MASTER_ID)+",2,"+String(lastSeqTx)+",RYLR896";
    String cmd = "AT+SEND=0," + String(payload.length()) + "," + payload;
    (void)sendAT(cmd, SEND_TO_MS);
    waitingAck = true; ackDeadline = millis() + ACK_WAIT_MS;
    ticGreen();
  }

  while(LORA.available()){
    String line = LORA.readStringUntil('\n'); line.trim();
    if(!line.length()) continue;
    if(line.startsWith("+RCV=")) handleRCVForAck(line);
  }

  if(waitingAck && (long)(millis()-ackDeadline) >= 0){
    waitingAck=false;
    if(++ackFailStreak >= ACK_FAIL_THRESH){}
  }

  driveConnLED();
}